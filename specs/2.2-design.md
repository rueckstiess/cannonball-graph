Today we're working on the implementation plan point 2.2 (see specs/rules.md).

  #### 2.2 Relationship Pattern Matching
  - Implement matching for relationship types
  - Implement matching for relationship properties
  - Implement direction-aware relationship traversal


  We already have node matching, so this is about relationship pattern matching. You can take a look at the existing pattern-matcher.ts file which we'll extend.
  Also check the existing tests under pattern-matcher.test.ts and e2e-pattern-matching.test.ts.

  Review the project as it is so far, then think through a high level design for task 2.2. As always, we first come up with a high level design, then add types
  and interfaces, then write the unit tests for TDD. pause there before writing the implementation itself.

✻ Thinking…

  Let's review the project structure and the specific task at hand, which is to implement relationship pattern matching as part of the 2.2 milestone.

  Based on the files I've examined, the project has:

  1. A graph data structure implementation in src/graph/ with comprehensive interfaces for nodes and edges (relationships)
  2. A rules module in src/rules/ with a pattern matching capability that currently only matches nodes (as evidenced by the pattern-matcher.ts file)
  3. Tests in __test__/ that verify both unit functionality and end-to-end scenarios

  The task specifically is to extend the pattern matcher to handle relationship patterns, including:
  - Matching relationship types
  - Matching relationship properties
  - Direction-aware relationship traversal

  Currently, the PatternMatcher class in pattern-matcher.ts only has methods for matching nodes:
  - findMatchingNodes: Finds nodes that match a specific pattern
  - matchesNodePattern: Checks if a specific node matches a pattern
  - getNodesByLabel: Gets nodes by a specific label

  To implement relationship pattern matching, we'll need to extend this with similar functionality for relationships (edges).

  Looking at the current structure of the Pattern Matcher, it seems to be designed with node-centric matching in mind. For relationship matching, we'll need to:

  1. Define interfaces and methods for relationship pattern matching
  2. Implement the logic to match relationships based on:
    - Type (similar to node labels)
    - Properties (similar to node properties)
    - Direction (outgoing, incoming, or both)
  3. Write tests to verify the matching functionality

  Now let's look at the types defined in src/rules/types.ts to understand what relationship patterns look like:

  export interface RelationshipPattern {
    /** Variable name to reference the relationship (optional) */
    variable?: string;
    /** Relationship type (optional) */
    type?: string;
    /** Property constraints (optional) */
    properties: Record<string, string | number | boolean | null>;
    /** Direction of the relationship: 'outgoing' (->), 'incoming' (<-), or 'both' (-) */
    direction: 'outgoing' | 'incoming' | 'both';
    /** Min path length for variable-length relationships (optional) */
    minHops?: number;
    /** Max path length for variable-length relationships (optional) */
    maxHops?: number;
  }

  And a path pattern combines nodes and relationships:

  export interface PathPattern {
    /** Starting node pattern */
    start: NodePattern;
    /** Array of relationships and nodes that form the path */
    segments: Array<{
      relationship: RelationshipPattern;
      node: NodePattern;
    }>;
  }

  Let's also look at the existing test files to understand how they're testing node matching, which will help us design our relationship matching tests.

  Based on what I've seen, here's a high-level design for the relationship pattern matching:

  1. Extend the PatternMatcher interface with new methods for relationship matching:
    - findMatchingRelationships: Find relationships in the graph that match a given pattern
    - matchesRelationshipPattern: Check if a specific relationship matches a pattern
    - getRelationshipsByType: Get relationships in the graph by type
  2. Update the PatternMatcher to implement these new methods.
  3. Consider adding path traversal capabilities to match a complete path pattern (a starting node followed by a sequence of relationships and nodes).

  Let's design the interface extensions and then the tests for these new methods.

  Here's what we'll add to the PatternMatcher interface:

  export interface PatternMatcher<NodeData = any, EdgeData = any> {
    // Existing methods
    findMatchingNodes(
      graph: Graph<NodeData, EdgeData>,
      pattern: NodePattern
    ): Node<NodeData>[];

    matchesNodePattern(
      node: Node<NodeData>,
      pattern: NodePattern
    ): boolean;

    getNodesByLabel(
      graph: Graph<NodeData, EdgeData>,
      label: string
    ): Node<NodeData>[];

    clearCache(): void;

    // New methods for relationship pattern matching
    findMatchingRelationships(
      graph: Graph<NodeData, EdgeData>,
      pattern: RelationshipPattern
    ): Edge<EdgeData>[];

    matchesRelationshipPattern(
      edge: Edge<EdgeData>,
      pattern: RelationshipPattern
    ): boolean;

    getRelationshipsByType(
      graph: Graph<NodeData, EdgeData>,
      type: string
    ): Edge<EdgeData>[];

    // Path pattern matching
    findMatchingPaths(
      graph: Graph<NodeData, EdgeData>,
      pattern: PathPattern
    ): Array<{
      nodes: Node<NodeData>[];
      relationships: Edge<EdgeData>[];
    }>;
  }

  Next, I would write tests for these new methods. The tests would verify:
  1. Basic relationship matching by type
  2. Relationship matching with property constraints
  3. Direction-aware matching (outgoing, incoming, both)
  4. Complete path pattern matching

  Let's structure the approach for developing this feature:

  1. Define the new interfaces and method signatures (as outlined above)
  2. Write tests for the new functionality
  3. Implement the methods in the PatternMatcher class
  4. Verify with both unit tests and end-to-end tests

⏺ Based on my review of the codebase, I'll outline a high-level design for implementing relationship pattern matching.

  Current State

  The PatternMatcher interface and PatternMatcher class currently support:
  - Finding nodes matching a pattern (findMatchingNodes)
  - Checking if a node matches a pattern (matchesNodePattern)
  - Getting nodes by label (getNodesByLabel)

  Design for Relationship Pattern Matching

  1. Interface Extensions

  We need to extend the PatternMatcher interface with methods for matching relationships:

  export interface PatternMatcher<NodeData = any, EdgeData = any> {
    // Existing methods...

    // New methods
    findMatchingRelationships(
      graph: Graph<NodeData, EdgeData>,
      pattern: RelationshipPattern
    ): Edge<EdgeData>[];

    matchesRelationshipPattern(
      edge: Edge<EdgeData>,
      source: Node<NodeData> | undefined,
      target: Node<NodeData> | undefined,
      pattern: RelationshipPattern
    ): boolean;

    getRelationshipsByType(
      graph: Graph<NodeData, EdgeData>,
      type: string
    ): Edge<EdgeData>[];

    // Path matching
    findMatchingPaths(
      graph: Graph<NodeData, EdgeData>,
      pattern: PathPattern
    ): Array<{
      nodes: Node<NodeData>[];
      edges: Edge<EdgeData>[];
    }>;
  }

  2. Implementation Considerations

  - Type Matching: Similar to matching node labels
  - Property Matching: Reuse the property matching logic from nodes
  - Direction Handling: Use the graph's direction-aware traversal capabilities
  - Caching: Potentially cache relationship type lookups like we do for node labels
  - Path Traversal: Implement a graph traversal algorithm that follows the pattern specification

  3. Test Cases to Develop

  1. Basic Relationship Matching
    - Match relationships by type
    - Match with exact/case-insensitive type matching
  2. Property Matching
    - Match relationships with simple properties
    - Match with multiple property constraints
    - Test type coercion (when enabled)
  3. Direction-Aware Matching
    - Match with outgoing direction
    - Match with incoming direction
    - Match with bidirectional relationships
  4. Path Pattern Matching
    - Match simple paths (node-relationship-node)
    - Match multi-segment paths
    - Handle non-matching segments