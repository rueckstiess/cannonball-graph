# Query Language Guide

Cannonball Graph supports a subset of the Cypher query language for declarative graph interaction. This guide details the supported syntax and features.

Reference:
*   Parser: [`src/lang/parser.ts`](../src/lang/parser.ts)
*   Query Engine: [`src/query/query-engine.ts`](../src/query/query-engine.ts)

## Basic Structure

A query typically consists of clauses executed in a specific order:

1.  `MATCH`: Specifies patterns to find in the graph.
2.  `WHERE`: Filters the results of the `MATCH` clause.
3.  `CREATE` / `SET` / `DELETE`: Modifies the graph based on matched patterns.
4.  `RETURN`: Specifies what data to output from the query.

A query can contain any combination of these clauses, but they generally follow this conceptual order. `CREATE`, `SET`, and `DELETE` clauses operate on the results produced by `MATCH` and `WHERE`.

## `MATCH` Clause

The `MATCH` clause is used to specify graph patterns.

### Node Patterns

Nodes are represented by parentheses `()`.

```cypher
-- Match any node
MATCH (n) RETURN n

-- Match nodes with a specific label
MATCH (p:Person) RETURN p

-- Match nodes with a label and specific properties
MATCH (u:User {name: "Alice"}) RETURN u

-- Assign the matched node to a variable ('p' or 'u' above)
MATCH (product:Product {category: "Electronics"}) RETURN product.price
```

*   **Variables:** `n`, `p`, `u`, `product` are variables bound to the matched nodes.
*   **Labels:** `:Person`, `:User`, `:Product` specify the required node label. Only single labels are currently supported in patterns.
*   **Properties:** `{name: "Alice"}`, `{category: "Electronics"}` filter nodes by property values. Values must be literals (string, number, boolean, null).

### Relationship Patterns

Relationships are represented by square brackets `[]` connecting two node patterns. Arrows indicate direction.

```cypher
-- Match outgoing relationships of type 'KNOWS' from any node 'a' to any node 'b'
MATCH (a)-[:KNOWS]->(b) RETURN a, b

-- Match incoming relationships of type 'ASSIGNED_TO' to a Task node
MATCH (p:Person)<-[:ASSIGNED_TO]-(t:Task) RETURN p, t

-- Match relationships of any type and any direction between two Person nodes
MATCH (p1:Person)-[]-(p2:Person) RETURN p1, p2

-- Assign the relationship to a variable 'r' and filter by property
MATCH (u:User)-[r:PURCHASED {discounted: true}]->(p:Product) RETURN u, r, p

-- Match relationships with a specific type using quotes (if type is a reserved keyword)
MATCH (a)-[:"ORDER"]->(b) RETURN a, b
```

*   **Direction:** `->` (outgoing), `<-` (incoming), `-` (either direction).
*   **Variable:** `r` is a variable bound to the matched relationship.
*   **Type:** `:KNOWS`, `:ASSIGNED_TO`, `:PURCHASED` specify the relationship type (label).
*   **Properties:** `{discounted: true}` filter relationships by property values.

### Path Patterns

Combine node and relationship patterns to form paths.

```cypher
MATCH (u:User {name: "Alice"})-[:KNOWS]->(friend:Person)-[:WORKS_AT]->(c:Company)
RETURN u, friend, c.name
```

### Multiple Patterns

Use commas to separate multiple independent patterns in a single `MATCH` clause. The results will be a Cartesian product of the matches for each pattern, filtered by any subsequent `WHERE` clause.

```cypher
MATCH (a:Person {name: "Alice"}), (b:Person {name: "Bob"})
RETURN a, b
```

### Variable-Length Paths

Specify paths of variable length using `*`.

```cypher
-- Match paths of 1 to 5 hops with 'KNOWS' relationships
MATCH (a:Person {name: "Alice"})-[:KNOWS*1..5]->(b:Person)
RETURN b

-- Match paths of any length (up to internal limit)
MATCH (a:User)-[:REPORTS_TO*]->(manager:User {is_manager: true})
RETURN a, manager

-- Match paths of at least 2 hops
MATCH (c:City)-[:CONNECTED_TO*2..]->(other:City)
RETURN c, other

-- Match paths up to 3 hops
MATCH (start)-[*..3]->(end)
RETURN start, end
```

*   `*`: Any length (1 or more, limited by internal defaults).
*   `*min..max`: Length between `min` and `max` hops (inclusive).
*   `*min..`: Length of at least `min` hops.
*   `*..max`: Length up to `max` hops (inclusive, starting from 1).

**Note:** Variable-length path queries can be computationally expensive. Default limits apply.

## `WHERE` Clause

The `WHERE` clause filters the results generated by `MATCH`. It uses boolean expressions.

### Comparisons

```cypher
MATCH (p:Person)
WHERE p.age > 30
RETURN p.name

MATCH (p:Product)
WHERE p.category = "Books"
RETURN p.title

MATCH (u:User)
WHERE u.age < 40
RETURN u

MATCH (n)
WHERE n.name <> "Admin"
RETURN n
```

*   Supported operators: `=`, `<>`, `<`, `<=`, `>`, `>=`.

### Property Existence

```cypher
MATCH (n)
WHERE n.email IS NOT NULL
RETURN n

MATCH (p:Product)
WHERE p.discount IS NULL
RETURN p
```

*   Operators: `IS NULL`, `IS NOT NULL`.

### String Matching

```cypher
MATCH (p:Person)
WHERE p.name STARTS WITH "A"
RETURN p.name

MATCH (c:Comment)
WHERE c.text CONTAINS "graph database"
RETURN c

MATCH (f:File)
WHERE f.path ENDS WITH ".log"
RETURN f
```

*   Operators: `STARTS WITH`, `ENDS WITH`, `CONTAINS`. Case-sensitive.

### List Membership

:warn:  Not implemented yet

```cypher
MATCH (p:Product)
WHERE p.category IN ["Books", "Movies"]
RETURN p

MATCH (u:User)
WHERE u.id IN [101, 102, 105] -- Assumes IDs are numbers
RETURN u
```

*   Operator: `IN`. The right-hand side must be a literal list.

### Logical Operators

Combine conditions using `AND`, `OR`, `NOT`, `XOR`.

```cypher
MATCH (p:Person)
WHERE p.age >= 18 AND p.country = "USA"
RETURN p

MATCH (t:Task)
WHERE t.priority = "High" OR t.status = "COMPLETE"
RETURN t

MATCH (u:User)
WHERE NOT u.isAdmin
RETURN u
```

### `EXISTS` Sub-patterns

Check for the existence of a pattern related to matched variables.

```cypher
-- Find users who have purchased at least one product
MATCH (u:User)
WHERE EXISTS((u)-[:PURCHASED]->(:Product))
RETURN u

-- Find products that have no reviews
MATCH (p:Product)
WHERE NOT EXISTS((:Review)-[:REVIEWS]->(p))
RETURN p
```

*   `EXISTS(...)`: Evaluates to true if the pattern inside the parentheses matches at least once.
*   `NOT EXISTS(...)`: Evaluates to true if the pattern inside does not match.
*   Variables defined *outside* the `EXISTS` pattern can be used inside it to constrain the sub-match (like `u` and `p` above).
*   Variables defined *inside* the `EXISTS` pattern are local to that check and cannot be used outside or returned.

## `CREATE` Clause

The `CREATE` clause adds new nodes and relationships to the graph.

### Creating Nodes

```cypher
-- Create a single node
CREATE (p:Person {name: "Charlie", age: 35})

-- Create multiple nodes
CREATE (:Product {sku: "XYZ", price: 19.99}), (:Category {name: "Clothing"})
```

*   Nodes created via `CREATE` are independent unless linked by subsequent `CREATE` relationship clauses within the same query or by using `MATCH` first.

### Creating Relationships

Relationships in `CREATE` must connect nodes that have already been bound by a preceding `MATCH` clause or created earlier in the *same* `CREATE` clause (though matching existing nodes first is more common).

```cypher
-- Match existing nodes and create a relationship between them
MATCH (a:Person {name: "Alice"}), (b:Person {name: "Bob"})
CREATE (a)-[r:KNOWS {since: 2021}]->(b)
RETURN a, r, b

-- Create nodes and a relationship simultaneously (less common, requires careful variable handling)
CREATE (p:Person {name: "David"})-[rel:WORKS_FOR]->(c:Company {name: "Acme Corp"})
RETURN p, rel, c
```

*   You must provide variables for the start and end nodes (`a`, `b` or `p`, `c` above).
*   You can optionally assign the created relationship to a variable (`r`, `rel`).

## `SET` Clause

The `SET` clause modifies properties on existing nodes or relationships identified by `MATCH`.

```cypher
-- Update a property on matched nodes
MATCH (p:Person {name: "Alice"})
SET p.age = 31
RETURN p

-- Add a new property
MATCH (u:User {id: "user1"})
SET u.lastModified = timestamp() -- Example: requires timestamp function

-- Update multiple properties
MATCH (p:Product {sku: "XYZ"})
SET p.price = 24.99, p.inStock = true

-- Update properties on a relationship
MATCH (:User {name: "Alice"})-[r:KNOWS]->(:Person {name: "Bob"})
SET r.strength = 0.8
```

*   `SET` replaces the existing value of a property or adds the property if it doesn't exist.
*   To remove a property, you would typically `SET` its value to `null` (explicit `REMOVE` is not currently supported via the query language, though `graph.updateNodeData` can achieve it programmatically).

## `DELETE` / `DETACH DELETE` Clause

The `DELETE` clause removes nodes and relationships identified by `MATCH`.

```cypher
-- Delete a specific node (only if it has no relationships)
MATCH (p:Person {name: "Obsolete User"})
DELETE p

-- Delete a specific relationship
MATCH (:User {name: "Alice"})-[r:OLD_CONNECTION]->(:Service)
DELETE r

-- Delete multiple nodes/relationships
MATCH (temp:TemporaryData)-[rel]-(other)
DELETE temp, rel
```

*   **`DELETE`** on a node will fail if the node has any relationships attached.
*   **`DETACH DELETE`** must be used to delete a node *and* all its relationships simultaneously.

```cypher
-- Delete a node and all its relationships
MATCH (u:User {status: "inactive"})
DETACH DELETE u
```

## `RETURN` Clause

The `RETURN` clause specifies what data the query should output.

```cypher
-- Return entire nodes or relationships
MATCH (p:Person)-[r:KNOWS]->(f:Person)
RETURN p, r, f

-- Return specific properties
MATCH (u:User {isActive: true})
RETURN u.name, u.email

-- Return literals (less common, but possible)
RETURN "Query Complete", 123
```

*   Currently, only variables representing nodes/relationships or property accesses (`variable.property`) can be returned.
*   Aliases (`RETURN p.name AS personName`) are **not** supported.
*   Aggregation functions (`count()`, `collect()`, etc.) are **not** supported.
*   Map projections (`RETURN p { .name, .age }`) are **not** supported.

## Unsupported Cypher Features (Notable Examples)

Cannonball Graph's query language is a *subset* of Cypher. Key features **not** currently supported include:

*   `MERGE` (atomic create-or-match)
*   `OPTIONAL MATCH`
*   `REMOVE` property/label
*   `UNION` / `UNION ALL`
*   `WITH` clause for chaining query parts
*   List/Map literals and manipulation functions
*   Aggregation functions (e.g., `count()`, `sum()`, `avg()`, `collect()`, `min()`, `max()`)
*   Path variables (`MATCH path = (a)-[*]-(b) RETURN path`)
*   Parameterization (`$param`)
*   Indexes and Constraints
*   Built-in functions (e.g., `id()`, `labels()`, `type()`, `timestamp()`, `date()`, string functions, math functions) - *Some might be added later.*
*   Aliases in `RETURN` (`AS`)
*   `ORDER BY`, `SKIP`, `LIMIT` clauses
*   Map projections in `RETURN`
*   Case expressions (`CASE WHEN ... THEN ... ELSE ... END`)
*   Subqueries in expressions

This list is not exhaustive. Assume a feature is unsupported unless explicitly mentioned in this guide.
